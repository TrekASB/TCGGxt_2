<!DOCTYPE html>
<html lang="nb">
<head>
  <meta charset="UTF-8" />
  <title>MultiProperty Labeler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>

  <style>
    :root{
      --primary:#0069d9; --success:#28a745; --danger:#e74c3c; --gray:#6c757d; --border:#dee2e6;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body{margin:0;background:#f5f5f7;color:#111827;min-height:100vh;display:flex;flex-direction:column;}
    header{
      display:flex;align-items:center;gap:12px;padding:12px 14px;background:#fff;border-bottom:1px solid #e5e7eb;
      font-size:14px;font-weight:700;flex-wrap:wrap;
    }
    header .status{margin-left:auto;font-weight:400;font-size:12px;opacity:.8;white-space:nowrap;}
    main{padding:12px;display:flex;flex-direction:column;gap:10px;}
    .card{background:#fff;border-radius:10px;box-shadow:0 1px 3px rgba(15,23,42,.06);padding:10px 12px;font-size:13px;}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;}
    label{font-weight:600;display:flex;align-items:center;gap:8px;white-space:nowrap;}
    select,button{
      padding:10px 12px;border-radius:8px;border:1px solid var(--border);font-size:13px;
    }
    select{min-width:260px;max-width:520px;background:#fff;}
    button{border:none;cursor:pointer;font-weight:700;color:#fff;display:inline-flex;align-items:center;gap:6px;}
    button:disabled{background:var(--gray);cursor:not-allowed;opacity:.85;}
    #scanBtn{background:var(--success);}
    #showBtn{background:var(--primary);}
    #clearBtn{background:var(--danger);}
    .muted{opacity:.75}
    #error{color:#b91c1c;font-size:12px;min-height:16px;white-space:pre-wrap;}
    .small{font-size:12px}
  </style>
</head>

<body>
<header>
  MultiProperty Labeler (p√•skrift i 3D)
  <span class="status" id="status">Kobler til Trimble Connect‚Ä¶</span>
</header>

<main>
  <div class="card">
    <div class="row">
      <button id="scanBtn" disabled>üîé Oppdater liste</button>

      <label>
        Property Set:
        <select id="psetSelect" disabled>
          <option value="">(velg‚Ä¶)</option>
        </select>
      </label>

      <label>
        Property:
        <select id="propSelect" disabled>
          <option value="">(velg‚Ä¶)</option>
        </select>
      </label>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="showBtn" disabled>üè∑Ô∏è Vis p√•skrift</button>
      <button id="clearBtn" disabled>üßπ Fjern p√•skrifter</button>
      <span class="muted small" id="info">
        Filtrerer bort IFCPROJECT / IFCSITE / IFCBUILDING / IFCBUILDINGSTOREY.
      </span>
    </div>

    <div id="error"></div>
  </div>

  <div class="card">
    <div class="small muted">
      Tips: Velg f.eks. <b>1_VA</b> ‚Üí <b>Diameter Kumlokk (mm)</b> og trykk ‚ÄúVis p√•skrift‚Äù.
      Husk √• sl√• p√• Markups/Annotations i visningen om du ikke ser tekst.
    </div>
  </div>
</main>

<script>
  let API = null;

  // Cache og state
  let availableProps = {};                 // { psetName: Set(props) }
  let lastMarkupIds = [];                  // markups vi har lagt til (for rydding)
  let lastObjectIndex = new Map();         // key: `${modelId}:${runtimeId}` -> {modelId, runtimeId}
  const ifcIdCache = new Map();            // key: `${modelId}:${runtimeId}` -> IfcGlobalId

  // UI
  const els = {
    status: document.getElementById("status"),
    error: document.getElementById("error"),
    info: document.getElementById("info"),
    scanBtn: document.getElementById("scanBtn"),
    showBtn: document.getElementById("showBtn"),
    clearBtn: document.getElementById("clearBtn"),
    psetSelect: document.getElementById("psetSelect"),
    propSelect: document.getElementById("propSelect")
  };

  function setStatus(msg){ els.status.textContent = msg; }
  function setError(msg){ els.error.textContent = msg || ""; }
  function norm(v){ return (v===null||v===undefined) ? "" : String(v).trim(); }
  function looksIfc(v){ const s = norm(v).toUpperCase(); return s.startsWith("IFC") ? s : ""; }

  // ============================
  // Filter: ignorer root/container entities
  // ============================
  const IGNORE_TYPES = new Set(["IFCPROJECT","IFCSITE","IFCBUILDING","IFCBUILDINGSTOREY"]);

  function containsIfcTypeAnywhere(obj, ifcTypeUpper){
    const target = ifcTypeUpper.toUpperCase();

    const direct = [obj.ifcType, obj.ifcEntity, obj.entityType, obj.type, obj.objectType, obj.className, obj.class];
    for (const c of direct){
      const t = looksIfc(c);
      if (t === target) return true;
    }

    const nameCandidates = [obj.name, obj.objectName];
    for (const c of nameCandidates){
      const s = norm(c).toUpperCase();
      if (s === target || s.includes(target)) return true;
    }

    for (const ps of (obj.properties || [])){
      const psName = norm(ps.name || ps.set).toUpperCase();
      if (psName === target) return true;

      for (const p of (ps.properties || [])){
        const pn = norm(p.name).toUpperCase();
        const pv = norm(p.value).toUpperCase();
        if (pn === target || pv === target) return true;
        if (pn.includes(target) || pv.includes(target)) return true;
      }
    }
    return false;
  }

  function getIfcEntityType(obj){
    const direct = looksIfc(obj.ifcType || obj.ifcEntity || obj.entityType || obj.type || obj.objectType || obj.className || obj.class);
    if (direct) return direct;

    const wanted = new Set([
      "IFC TYPE","IFCTYPE","IFC ENTITY","IFCENTITY","ENTITY","ENTITY TYPE","ENTITYTYPE",
      "CLASS","CLASSNAME","OBJECTTYPE","OBJECT TYPE","COMMON TYPE","IFC CLASS","IFCCLASS"
    ]);

    const psets = obj.properties || [];
    for (const ps of psets){
      for (const p of (ps.properties || [])){
        const pn = norm(p.name).toUpperCase();
        if (!wanted.has(pn)) continue;
        const t = looksIfc(p.value);
        if (t) return t;
      }
    }
    return "";
  }

  function isIgnored(obj){
    const t = getIfcEntityType(obj);
    if (t && IGNORE_TYPES.has(t)) return true;
    for (const it of IGNORE_TYPES){
      if (containsIfcTypeAnywhere(obj, it)) return true;
    }
    return false;
  }
  // ============================

  // ===== IFC GlobalId (IFC GUID) via convertToObjectIds =====
  async function getIfcGlobalIdCached(modelId, runtimeId){
    const key = `${modelId}:${runtimeId}`;
    if (ifcIdCache.has(key)) return ifcIdCache.get(key);

    let v = "";
    try{
      const ids = await API.viewer.convertToObjectIds(modelId, [Number(runtimeId)]);
      v = (ids && ids[0]) ? String(ids[0]) : "";
    }catch(e){ v = ""; }

    ifcIdCache.set(key, v);
    return v;
  }
  // =========================================================

  // ------- Markup helpers -------
  async function clearAllMarkups(){
    try{
      if (!API || !API.markup || typeof API.markup.removeMarkups !== "function") return;
      if (lastMarkupIds.length){
        await API.markup.removeMarkups(lastMarkupIds);
      }
    }catch(e){
      console.warn("removeMarkups feilet:", e);
    }finally{
      lastMarkupIds = [];
      setStatus("üßπ P√•skrifter fjernet.");
    }
  }

  async function addLabelForObject(modelId, runtimeId, labelText){
    if (!API.markup || typeof API.markup.addTextMarkup !== "function") return null;

    const boxes = await API.viewer.getObjectBoundingBoxes(modelId, [runtimeId]);
    if (!boxes || !boxes.length || !boxes[0] || !boxes[0].boundingBox) return null;

    const bb = boxes[0].boundingBox;
    const min = bb.min, max = bb.max;

    // Antakelse (som i eksempelkoden din): Y er opp, viewer-coords i meter -> markup expects mm
    const centerX_mm = ((min.x + max.x) / 2.0) * 1000.0;
    const centerZ_mm = ((min.z + max.z) / 2.0) * 1000.0;
    const topY_mm    = (max.y) * 1000.0;

    const startPick = {
      positionX: centerX_mm,
      positionY: topY_mm + 200.0,    // 0.2m over topp
      positionZ: centerZ_mm,
      modelId: modelId,
      objectId: runtimeId
    };
    const endPick = {
      positionX: centerX_mm,
      positionY: topY_mm + 1200.0,   // 1.2m over topp
      positionZ: centerZ_mm,
      modelId: modelId,
      objectId: runtimeId
    };

    const textMarkup = {
      start: startPick,
      end: endPick,
      text: labelText,
      color: { r: 0, g: 0, b: 204, a: 255 }
    };

    const created = await API.markup.addTextMarkup([textMarkup]);
    if (created && created.length && typeof created[0].id === "number") return created[0].id;
    return null;
  }

  // ------- Property utilities -------
  function getPsetName(ps){
    // TC kan bruke name eller set
    return ps.name || ps.set || "";
  }

  function getPsetProps(ps){
    return ps.properties || [];
  }

  function findPropValue(objProps, targetPsetName, targetPropName){
    const psets = objProps.properties || [];
    for (const ps of psets){
      const psName = getPsetName(ps);
      if (psName !== targetPsetName) continue;

      for (const p of getPsetProps(ps)){
        if (p.name === targetPropName){
          const v = p.value;
          if (v === null || v === undefined) return "";
          const s = String(v).trim();
          return s;
        }
      }
    }
    return "";
  }

  // ------- Scan all objects and build Pset/Prop list -------
  async function scanModel(){
    if (!API){ setError("API ikke klar."); return; }

    setError("");
    setStatus("üîç Skanner modell‚Ä¶");
    availableProps = {};
    lastObjectIndex = new Map();

    els.psetSelect.disabled = true;
    els.propSelect.disabled = true;
    els.showBtn.disabled = true;

    try{
      const models = await API.viewer.getObjects();
      if (!models || !models.length){
        setStatus("‚ÑπÔ∏è Fant ingen objekter i visningen.");
        return;
      }

      for (const m of models){
        const modelId = m.modelId || m.modelid || m["model Id"];
        const objs = m.objects || [];
        if (!modelId || !objs.length) continue;

        const runtimeIds = objs.map(o => o.id);
        const objPropsArr = await API.viewer.getObjectProperties(modelId, runtimeIds);

        for (const obj of (objPropsArr || [])){
          if (isIgnored(obj)) continue;

          // indeks for senere (vi trenger runtimeId til markup)
          lastObjectIndex.set(`${modelId}:${obj.id}`, { modelId, runtimeId: obj.id });

          for (const ps of (obj.properties || [])){
            const psName = getPsetName(ps);
            if (!psName) continue;

            if (!availableProps[psName]) availableProps[psName] = new Set();
            for (const p of getPsetProps(ps)){
              if (p && p.name) availableProps[psName].add(p.name);
            }
          }
        }
      }

      const psets = Object.keys(availableProps).sort((a,b)=>a.localeCompare(b,"nb"));
      els.psetSelect.innerHTML = `<option value="">(velg‚Ä¶)</option>` +
        psets.map(p => `<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`).join("");

      els.psetSelect.disabled = !psets.length;
      setStatus(psets.length ? "‚úÖ Skann ferdig ‚Äì velg Pset og Property." : "‚ÑπÔ∏è Ingen Pset funnet (etter filtrering).");
    }catch(e){
      console.error(e);
      setError("Feil under skanning: " + (e.message || e));
      setStatus("‚ùå Skann feilet.");
    }
  }

  function populatePropSelect(psetName){
    els.propSelect.innerHTML = `<option value="">(velg‚Ä¶)</option>`;
    els.propSelect.disabled = true;
    els.showBtn.disabled = true;

    if (!psetName || !availableProps[psetName]) return;

    const props = Array.from(availableProps[psetName]).sort((a,b)=>a.localeCompare(b,"nb"));
    els.propSelect.innerHTML = `<option value="">(velg‚Ä¶)</option>` +
      props.map(p => `<option value="${escapeHtml(p)}">${escapeHtml(p)}</option>`).join("");

    els.propSelect.disabled = false;
  }

  // ------- Show labels for ALL objects that have selected value -------
  async function showLabels(){
    const psetName = els.psetSelect.value;
    const propName = els.propSelect.value;
    if (!psetName || !propName){
      setError("Velg b√•de Property Set og Property.");
      return;
    }

    setError("");

    if (!API.markup || typeof API.markup.addTextMarkup !== "function"){
      setError("Markup API er ikke tilgjengelig i denne visningen. (Kan ikke vise 3D-tekst.)");
      return;
    }

    setStatus("üß† Leser objekter og lager p√•skrifter‚Ä¶");
    els.showBtn.disabled = true;

    try{
      // Rydd bort gamle f√∏rst
      await clearAllMarkups();

      const models = await API.viewer.getObjects();
      let createdCount = 0;
      let withValueCount = 0;
      let skippedNoBB = 0;

      for (const m of models){
        const modelId = m.modelId || m.modelid || m["model Id"];
        const objs = m.objects || [];
        if (!modelId || !objs.length) continue;

        const runtimeIds = objs.map(o => o.id);
        const objPropsArr = await API.viewer.getObjectProperties(modelId, runtimeIds);

        for (const obj of (objPropsArr || [])){
          if (isIgnored(obj)) continue;

          const val = findPropValue(obj, psetName, propName);
          if (!val) continue;

          withValueCount++;

          // Tekst: kun verdien (som du √∏nsket), men lett √• utvide med objektnavn / IfcGlobalId
          // const ifcId = await getIfcGlobalIdCached(modelId, obj.id);
          const labelText = `${val}`;

          const id = await addLabelForObject(modelId, obj.id, labelText);
          if (typeof id === "number"){
            lastMarkupIds.push(id);
            createdCount++;
          } else {
            skippedNoBB++;
          }
        }
      }

      setStatus(`üè∑Ô∏è Ferdig: Laget ${createdCount} p√•skrifter (fant ${withValueCount} med verdi).`);
      if (skippedNoBB){
        setError(`Merk: ${skippedNoBB} objekter hadde ikke bounding box, og fikk derfor ikke tekst.`);
      }
      els.clearBtn.disabled = false;
    }catch(e){
      console.error(e);
      setError("Feil ved opprettelse av p√•skrifter: " + (e.message || e));
      setStatus("‚ùå Kunne ikke lage p√•skrifter.");
    }finally{
      els.showBtn.disabled = false;
    }
  }

  // ------- Helpers -------
  function escapeHtml(str){
    return String(str || "")
      .replace(/&/g,"&amp;")
      .replace(/</g,"&lt;")
      .replace(/>/g,"&gt;")
      .replace(/"/g,"&quot;")
      .replace(/'/g,"&#039;");
  }

  // ------- Events / init -------
  async function connect(){
    try{
      API = await TrimbleConnectWorkspace.connect(window.parent, () => {}, 30000);
      setStatus("‚úÖ Tilkoblet ‚Äì trykk ¬´Oppdater liste¬ª.");
      els.scanBtn.disabled = false;

      if (!API.markup || typeof API.markup.addTextMarkup !== "function"){
        setError("Merk: Markup API ser ikke ut til √• v√¶re tilgjengelig ‚Äì 3D-tekst kan v√¶re deaktivert i denne visningen.");
      }
    }catch(e){
      setError("Kunne ikke koble til Trimble Connect: " + (e && e.message ? e.message : e));
      setStatus("‚ùå Feil ved tilkobling.");
    }
  }

  els.scanBtn.onclick = scanModel;
  els.showBtn.onclick = showLabels;
  els.clearBtn.onclick = clearAllMarkups;

  els.psetSelect.onchange = () => {
    populatePropSelect(els.psetSelect.value);
    els.clearBtn.disabled = (lastMarkupIds.length === 0);
  };

  els.propSelect.onchange = () => {
    els.showBtn.disabled = !(els.psetSelect.value && els.propSelect.value);
  };

  // enable clear if any
  els.clearBtn.disabled = true;

  // Start
  connect();
</script>
</body>
</html>
