<!DOCTYPE html>
<html lang="nb">
<head>
  <meta charset="UTF-8" />
  <title>MultiProperty Labeler</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Trimble Connect Workspace API -->
  <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>

  <style>
    :root{
      --primary:#0069d9; --success:#28a745; --danger:#e74c3c; --gray:#6c757d; --border:#e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body{
      margin:0; background:#f5f5f7; color:#111827; min-height:100vh; display:flex; flex-direction:column;
    }
    header{
      display:flex; align-items:center; gap:14px;
      padding:12px 14px; background:#fff; border-bottom:1px solid var(--border);
    }
    .logoBox{
      width:90px; height:90px; border-radius:10px; background:#fff; border:1px solid #eee;
      display:flex; align-items:center; justify-content:center; overflow:hidden;
      box-shadow:0 1px 3px rgba(15,23,42,.08);
      flex:0 0 auto;
    }
    .logoBox img{ width:84px; height:84px; object-fit:contain; display:block; }
    .titleBlock{display:flex; flex-direction:column; gap:2px;}
    .title{font-weight:800; font-size:18px; color:var(--primary); line-height:1.1;}
    .org{font-weight:700; font-size:13px; opacity:.9;}
    .dev{font-size:11px; opacity:.75; font-style:italic;}
    .status{margin-left:auto; font-size:12px; opacity:.8; white-space:nowrap;}

    main{ padding:12px; display:flex; flex-direction:column; gap:10px; }
    .card{
      background:#fff; border-radius:10px; box-shadow:0 1px 3px rgba(15,23,42,.06);
      padding:12px;
    }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    label{ font-size:13px; font-weight:700; display:flex; align-items:center; gap:8px; }
    select,button,input[type="number"]{
      border:1px solid var(--border); border-radius:8px; padding:9px 10px; font-size:13px; background:#fff;
    }
    select{ min-width:220px; max-width:360px; }
    button{
      color:#fff; border:none; cursor:pointer; font-weight:800;
      display:inline-flex; align-items:center; gap:8px;
      padding:10px 12px;
    }
    button:disabled{opacity:.55; cursor:not-allowed;}
    #scanButton{background:var(--success);}
    #applyButton{background:#00c2cb;}
    #clearButton{background:var(--danger);}
    .hint{font-size:12px; opacity:.75; line-height:1.45;}
    #error{ color:#b91c1c; font-size:12px; min-height:16px; white-space:pre-wrap; }
    .small{font-size:12px; opacity:.8;}
    .pill{
      display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px;
      background:#f3f4f6; border:1px solid #e5e7eb; font-size:12px;
    }
    .gridProps{
      display:grid; grid-template-columns: 1fr; gap:8px; margin-top:8px;
    }
    .propLine{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .propLine input{ transform:scale(1.05); }
    @media (min-width: 880px){
      .gridProps{ grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>

<body>
  <header>
    <div class="logoBox">
      <img id="logo" src="norconsult-logo-black.png" alt="Norconsult logo"
           onerror="this.style.display='none'; this.parentElement.textContent='Norconsult'; this.parentElement.style.fontWeight='800';">
    </div>
    <div class="titleBlock">
      <div class="title">MultiProperty Checker</div>
      <div class="org">Norconsult Norge</div>
      <div class="dev">Developed by Edin Dzakmic, Norconsult, (AI-assisted development)</div>
    </div>
    <div class="status" id="status">Kobler til Trimble Connect‚Ä¶</div>
  </header>

  <main>
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="pill">üè∑Ô∏è P√•skrift i 3D via <b>API.markup.addTextMarkup</b> (samme metode som BIK)</div>
        <div class="pill">‚õî Filtrerer bort: IFCPROJECT / IFCSITE / IFCBUILDING / IFCBUILDINGSTOREY</div>
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="scanButton" disabled>üîÑ Oppdater liste</button>

        <label>
          Property Set:
          <select id="psetSelect" disabled><option value="">(velg‚Ä¶)</option></select>
        </label>
      </div>

      <div class="gridProps">
        <div class="propLine">
          <input type="checkbox" id="cb1">
          <label for="prop1">Property 1</label>
          <select id="prop1" disabled><option value="">(ingen)</option></select>
        </div>
        <div class="propLine">
          <input type="checkbox" id="cb2">
          <label for="prop2">Property 2</label>
          <select id="prop2" disabled><option value="">(ingen)</option></select>
        </div>
        <div class="propLine">
          <input type="checkbox" id="cb3">
          <label for="prop3">Property 3</label>
          <select id="prop3" disabled><option value="">(ingen)</option></select>
        </div>
        <div class="propLine">
          <input type="checkbox" id="cb4">
          <label for="prop4">Property 4</label>
          <select id="prop4" disabled><option value="">(ingen)</option></select>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <label style="gap:6px;">
          <input type="radio" name="scope" id="scopeSelected" checked>
          Bruk valgte objekter
        </label>
        <label style="gap:6px;">
          <input type="radio" name="scope" id="scopeAll">
          Bruk alle objekter (begrens)
        </label>

        <label title="Sikkerhetslimit hvis du velger alle objekter">
          Maks:
          <input id="maxObjects" type="number" value="200" min="1" max="5000" style="width:90px;">
        </label>

        <label style="gap:6px;" title="Tekst: 'Navn: Verdi' vs kun verdi">
          <input type="checkbox" id="showPropNames" checked>
          Vis property-navn
        </label>

        <label style="gap:6px;" title="Bruk objektets 'Objektnavn' f√∏rst hvis tilgjengelig">
          <input type="checkbox" id="includeObjectName" checked>
          Inkluder objektnavn
        </label>
      </div>

      <div class="row" style="margin-top:10px;">
        <button id="applyButton" disabled>üè∑Ô∏è Vis p√•skrift</button>
        <button id="clearButton" disabled>üßπ Fjern p√•skrift</button>
        <span class="small" id="runInfo"></span>
      </div>

      <div class="hint" style="margin-top:10px;">
        <b>Tips:</b> Sl√• p√• <b>Markups/Annotations</b> i 3D-visningen hvis du ikke ser teksten.<br>
        <b>Hvis ‚ÄúBruk valgte objekter‚Äù:</b> marker objekt f√∏rst i 3D (pil/selection), s√• trykk ‚ÄúVis p√•skrift‚Äù.
      </div>

      <div id="error"></div>
    </div>
  </main>

  <script>
    let API = null;
    let availableProps = {};
    let createdMarkupIds = []; // for removeMarkups
    const ifcIdCache = new Map();

    const IGNORE_TYPES = new Set(["IFCPROJECT","IFCSITE","IFCBUILDING","IFCBUILDINGSTOREY"]);

    const els = {
      status: document.getElementById("status"),
      error: document.getElementById("error"),
      runInfo: document.getElementById("runInfo"),

      scanButton: document.getElementById("scanButton"),
      applyButton: document.getElementById("applyButton"),
      clearButton: document.getElementById("clearButton"),

      psetSelect: document.getElementById("psetSelect"),
      scopeSelected: document.getElementById("scopeSelected"),
      scopeAll: document.getElementById("scopeAll"),
      maxObjects: document.getElementById("maxObjects"),
      showPropNames: document.getElementById("showPropNames"),
      includeObjectName: document.getElementById("includeObjectName")
    };

    const propSelectIds = ["prop1","prop2","prop3","prop4"];
    const cbIds = ["cb1","cb2","cb3","cb4"];

    function setStatus(msg){ els.status.textContent = msg; }
    function setError(msg){ els.error.textContent = msg || ""; }
    function normStr(v){ return (v===null||v===undefined) ? "" : String(v).trim(); }
    function normalizeName(name){
      return (name || "")
        .toString()
        .toUpperCase()
        .replace(/[^A-Z0-9]+/g, "_")
        .replace(/^_+|_+$/g, "");
    }

    function looksLikeIfcEntityName(v){
      const s = normStr(v).toUpperCase();
      return s.startsWith("IFC") ? s : "";
    }

    function getIfcEntityTypeFromObjectProps(obj){
      const direct = looksLikeIfcEntityName(obj.ifcType || obj.ifcEntity || obj.entityType || obj.type || obj.objectType || obj.className || obj.class);
      if (direct) return direct;

      const wantedPropNames = new Set([
        "IFC TYPE","IFCTYPE","IFC ENTITY","IFCENTITY","ENTITY","ENTITY TYPE","ENTITYTYPE",
        "CLASS","CLASSNAME","OBJECTTYPE","OBJECT TYPE","COMMON TYPE","IFC CLASS","IFCCLASS"
      ]);

      const psets = (obj.properties || []);
      const prioritized = [];
      const others = [];

      for (const ps of psets){
        const n = normStr(ps.name || ps.set).toLowerCase();
        if (n.includes("reference object") || n === "ifc" || n.includes("component attributes")) prioritized.push(ps);
        else others.push(ps);
      }

      for (const ps of prioritized.concat(others)){
        for (const p of (ps.properties || [])){
          const pn = normStr(p.name).toUpperCase();
          if (!wantedPropNames.has(pn)) continue;
          const t = looksLikeIfcEntityName(p.value);
          if (t) return t;
        }
      }
      return "";
    }

    function containsIfcTypeAnywhere(obj, ifcTypeUpper){
      const target = ifcTypeUpper.toUpperCase();
      const directCandidates = [obj.ifcType,obj.ifcEntity,obj.entityType,obj.type,obj.objectType,obj.className,obj.class];
      for (const c of directCandidates){
        const t = looksLikeIfcEntityName(c);
        if (t === target) return true;
      }
      const nameCandidates = [obj.name,obj.objectName];
      for (const c of nameCandidates){
        const s = normStr(c).toUpperCase();
        if (s === target || s.includes(target)) return true;
      }
      for (const ps of (obj.properties || [])){
        const psName = normStr(ps.name || ps.set).toUpperCase();
        if (psName === target) return true;
        for (const p of (ps.properties || [])){
          const pn = normStr(p.name).toUpperCase();
          const pv = normStr(p.value).toUpperCase();
          if (pn === target || pv === target) return true;
          if (pn.includes(target) || pv.includes(target)) return true;
        }
      }
      return false;
    }

    function isIgnoredIfcEntity(obj){
      const t = getIfcEntityTypeFromObjectProps(obj);
      if (t && IGNORE_TYPES.has(t)) return true;
      for (const it of IGNORE_TYPES){
        if (containsIfcTypeAnywhere(obj, it)) return true;
      }
      return false;
    }

    // --- Selection robust (samme som tidligere, men enkel) ---
    function extractRuntimeIdsFromSelectionEntry(entry){
      if (!entry) return [];
      const candidates = [
        entry.objectRuntimeIds,
        entry.objectIds,
        entry.ids,
        entry.runtimeIds
      ];
      for (const c of candidates){
        if (Array.isArray(c) && c.length) return c.map(Number).filter(n=>Number.isFinite(n));
      }
      return [];
    }

    async function getSelectedRuntimeIdsPerModel(){
      const map = new Map();
      const sel = await API.viewer.getSelection();
      const list = (sel && Array.isArray(sel.modelObjectIds)) ? sel.modelObjectIds : [];
      for (const entry of list){
        const modelId = entry.modelId;
        const ids = extractRuntimeIdsFromSelectionEntry(entry);
        if (modelId !== undefined && ids.length) map.set(String(modelId), ids);
      }
      return map;
    }

    // --- IFC GlobalId (IFC GUID) cache (nyttig ved debugging) ---
    async function getIfcGlobalIdCached(modelId, runtimeId){
      const key = `${modelId}:${runtimeId}`;
      if (ifcIdCache.has(key)) return ifcIdCache.get(key);
      let v = "";
      try{
        const ids = await API.viewer.convertToObjectIds(modelId, [Number(runtimeId)]);
        v = (ids && ids[0]) ? String(ids[0]) : "";
      }catch{}
      ifcIdCache.set(key, v);
      return v;
    }

    // --- Finn object name (samme robusthet som BIK, men generisk) ---
    function findObjectName(objProps){
      const psets = objProps.properties || [];
      for (const pset of psets){
        const psetNameRaw = (pset.set || pset.name || "");
        const psetNameNorm = normalizeName(psetNameRaw);
        const props = pset.properties || [];

        for (const p of props){
          const nameRaw = p.name || "";
          const norm = normalizeName(nameRaw);

          if (norm === "OBJEKTNAVN") return String(p.value || "");
          if (norm.indexOf("OBJEKTNAVN") >= 0) return String(p.value || "");

          if (psetNameNorm === "WS_PSET" && nameRaw.toLowerCase() === "objektnavn"){
            return String(p.value || "");
          }
        }
      }
      return "";
    }

    function getPropValue(objProps, psetName, propName){
      const psets = objProps.properties || [];
      for (const pset of psets){
        const pn = pset.name || pset.set || "";
        if (pn !== psetName) continue;
        for (const p of (pset.properties || [])){
          if (p.name === propName) return p.value;
        }
      }
      return undefined;
    }

    function buildLabelText(objProps, pset, selectedProps, showNames, includeObjectName){
      const lines = [];

      if (includeObjectName){
        const on = findObjectName(objProps);
        if (normStr(on)) lines.push(String(on));
      }

      for (const prop of selectedProps){
        const v = getPropValue(objProps, pset, prop);
        const vs = normStr(v);
        if (!vs) continue; // ikke skriv tomme linjer
        lines.push(showNames ? `${prop}: ${vs}` : `${vs}`);
      }

      // M√• ha minst √©n linje (objektnavn eller property)
      return lines.length ? lines.join("\n") : "";
    }

    // ===== MARKUP METODIKK (identisk prinsipp som BIK) =====
    async function clearAllMarkups(){
      try{
        if (!API || !API.markup || typeof API.markup.removeMarkups !== "function") return;
        if (createdMarkupIds.length){
          await API.markup.removeMarkups(createdMarkupIds.slice());
          createdMarkupIds = [];
        }
      }catch(err){
        console.warn("Klarte ikke √• fjerne markups:", err);
      }
    }

    async function addTextMarkupForObject(modelId, runtimeId, text){
      if (!API || !API.markup || typeof API.markup.addTextMarkup !== "function") {
        throw new Error("MarkupAPI (API.markup.addTextMarkup) er ikke tilgjengelig i denne workspacen.");
      }

      const boxes = await API.viewer.getObjectBoundingBoxes(modelId, [runtimeId]);
      if (!boxes || !boxes.length || !boxes[0] || !boxes[0].boundingBox) return null;

      const bb = boxes[0].boundingBox;
      const min = bb.min;
      const max = bb.max;

      // Anta Y=opp (samme som BIK-koden)
      const centerX_mm = ((min.x + max.x) / 2.0) * 1000.0;
      const centerZ_mm = ((min.z + max.z) / 2.0) * 1000.0;
      const topY_mm    = (max.y) * 1000.0;

      const startPick = {
        positionX: centerX_mm,
        positionY: topY_mm + 200.0,    // 0.2 m over topp
        positionZ: centerZ_mm,
        modelId: modelId,
        objectId: runtimeId
      };

      const endPick = {
        positionX: centerX_mm,
        positionY: topY_mm + 1200.0,   // 1.2 m over topp
        positionZ: centerZ_mm,
        modelId: modelId,
        objectId: runtimeId
      };

      const textMarkup = {
        start: startPick,
        end: endPick,
        text: text,
        color: { r: 0, g: 0, b: 204, a: 255 } // m√∏rk bl√•
      };

      const created = await API.markup.addTextMarkup([textMarkup]);
      if (created && created.length && typeof created[0].id === "number"){
        createdMarkupIds.push(created[0].id);
        return created[0].id;
      }
      return null;
    }
    // =======================================================

    function resetPropertySelectors(){
      propSelectIds.forEach(id => {
        const s = document.getElementById(id);
        s.innerHTML = '<option value="">(ingen)</option>';
        s.disabled = true;
      });
      cbIds.forEach(id => document.getElementById(id).checked = false);
    }

    function populatePropSelects(pset){
      resetPropertySelectors();
      if (!pset || !availableProps[pset]) return;

      const props = Array.from(availableProps[pset]).sort((a,b)=>a.localeCompare(b,"nb"));
      propSelectIds.forEach(id => {
        const sel = document.getElementById(id);
        props.forEach(p => {
          const opt = document.createElement("option");
          opt.value = p;
          opt.textContent = p;
          sel.appendChild(opt);
        });
        sel.disabled = false;
      });
    }

    function getSelectedProps(){
      const selected = [];
      for (let i=1;i<=4;i++){
        const cb = document.getElementById(`cb${i}`);
        const sel = document.getElementById(`prop${i}`);
        if (cb.checked && sel && sel.value) selected.push(sel.value);
      }
      return selected;
    }

    async function scanProperties(){
      setError("");
      els.runInfo.textContent = "";
      availableProps = {};

      els.psetSelect.disabled = true;
      els.psetSelect.innerHTML = '<option value="">(velg‚Ä¶)</option>';
      resetPropertySelectors();

      setStatus("Skanner modell for Property Sets‚Ä¶");

      try{
        const models = await API.viewer.getObjects();
        if (!models || !models.length){
          setStatus("Fant ingen objekter i visningen.");
          return;
        }

        for (const m of models){
          const modelId = String(m.modelId || m.modelid || m["model Id"] || "");
          const objs = m.objects || [];
          if (!modelId || !objs.length) continue;

          const runtimeIds = objs.map(o => o.id);
          const objProps = await API.viewer.getObjectProperties(modelId, runtimeIds);

          for (const obj of (objProps || [])){
            if (isIgnoredIfcEntity(obj)) continue;

            for (const pset of (obj.properties || [])){
              const name = pset.name || pset.set || "";
              if (!name) continue;
              if (!availableProps[name]) availableProps[name] = new Set();
              for (const p of (pset.properties || [])){
                if (p.name) availableProps[name].add(p.name);
              }
            }
          }
        }

        const psets = Object.keys(availableProps).sort((a,b)=>a.localeCompare(b,"nb"));
        if (!psets.length){
          setStatus("Ingen Property Sets funnet (etter filtrering).");
          return;
        }

        for (const p of psets){
          const opt = document.createElement("option");
          opt.value = p;
          opt.textContent = p;
          els.psetSelect.appendChild(opt);
        }

        els.psetSelect.disabled = false;
        els.applyButton.disabled = false;
        setStatus("Ferdig. Velg Property Set og huk av opptil 4 properties.");
      }catch(err){
        console.error(err);
        setError("Feil ved skanning: " + (err.message || err));
        setStatus("Kunne ikke skanne.");
      }
    }

    async function applyLabels(){
      setError("");
      els.runInfo.textContent = "";

      const pset = els.psetSelect.value;
      if (!pset){
        setError("Velg et Property Set f√∏rst.");
        return;
      }

      const selectedProps = getSelectedProps();
      if (!selectedProps.length){
        setError("Huk av minst √©n property (opptil 4).");
        return;
      }

      const showNames = !!els.showPropNames.checked;
      const includeObjectName = !!els.includeObjectName.checked;

      setStatus("Fjerner gamle p√•skrifter‚Ä¶");
      await clearAllMarkups();

      setStatus("Samler objekter‚Ä¶");

      let perModelIds = new Map();

      try{
        if (els.scopeSelected.checked){
          perModelIds = await getSelectedRuntimeIdsPerModel();
          if (!perModelIds.size){
            setError("Ingen valgte objekter funnet. Marker objekt i 3D f√∏rst (pil/selection), og pr√∏v igjen.");
            setStatus("Ingen p√•skrift laget.");
            return;
          }
        } else {
          // all objects (limited)
          const max = Math.max(1, Math.min(5000, Number(els.maxObjects.value || 200)));
          const models = await API.viewer.getObjects();
          for (const m of (models || [])){
            const modelId = String(m.modelId || m.modelid || m["model Id"] || "");
            const objs = m.objects || [];
            if (!modelId || !objs.length) continue;
            const ids = objs.map(o=>o.id).slice(0, max).map(Number).filter(n=>Number.isFinite(n));
            if (ids.length) perModelIds.set(modelId, ids);
          }
        }

        if (!API.markup || typeof API.markup.addTextMarkup !== "function"){
          setError("MarkupAPI ikke tilgjengelig i denne workspacen. (API.markup.addTextMarkup mangler)");
          setStatus("Kan ikke lage 3D-tekst.");
          return;
        }

        setStatus("Leser egenskaper og lager 3D-tekst‚Ä¶");
        let created = 0;
        let considered = 0;

        for (const [modelId, ids] of perModelIds.entries()){
          if (!ids.length) continue;

          const objPropsArr = await API.viewer.getObjectProperties(modelId, ids);

          for (const objProps of (objPropsArr || [])){
            if (!objProps) continue;
            if (isIgnoredIfcEntity(objProps)) continue;

            considered++;

            const rid = objProps.id;
            const text = buildLabelText(objProps, pset, selectedProps, showNames, includeObjectName);
            if (!text) continue;

            // Optional debug: ensure GUID exists (not required for markup)
            // const ifcGuid = await getIfcGlobalIdCached(modelId, rid);

            const id = await addTextMarkupForObject(modelId, rid, text);
            if (id != null) created++;
          }
        }

        if (!created){
          setStatus("Ingen p√•skrift ble laget. Sjekk at valgt Pset/property faktisk har verdier p√• objektene.");
          els.clearButton.disabled = true;
          els.runInfo.textContent = `Vurdert: ${considered}.`;
        } else {
          setStatus("Viser 3D-tekst (sjekk at markups/annotations er sl√•tt p√• i viewer).");
          els.clearButton.disabled = false;
          els.runInfo.textContent = `Laget: ${created}. Vurdert: ${considered}.`;
        }
      }catch(err){
        console.error(err);
        setError("Feil ved opprettelse av p√•skrift: " + (err.message || err));
        setStatus("Kunne ikke lage 3D-tekst.");
      }
    }

    async function clearLabels(){
      setError("");
      setStatus("Fjerner p√•skrift‚Ä¶");
      await clearAllMarkups();
      els.clearButton.disabled = true;
      els.runInfo.textContent = "";
      setStatus("P√•skrift fjernet.");
    }

    function onWorkspaceEvent(event, payload){
      // (valgfritt) ‚Äì ikke n√∏dvendig for batch labels, men nyttig for debugging
      // console.log("Event:", event, payload);
    }

    async function connectToWorkspace(){
      API = await TrimbleConnectWorkspace.connect(window.parent, onWorkspaceEvent, 30000);

      console.log("Workspace API tilkoblet:", API);

      if (!API.markup || typeof API.markup.addTextMarkup !== "function") {
        setStatus("Tilkoblet (MarkupAPI ikke tilgjengelig ‚Äì 3D-tekst kan ikke tegnes).");
      } else {
        setStatus("Tilkoblet. Trykk ¬´Oppdater liste¬ª for √• skanne Pset.");
      }

      els.scanButton.disabled = false;
    }

    // UI events
    els.scanButton.onclick = scanProperties;
    els.applyButton.onclick = applyLabels;
    els.clearButton.onclick = clearLabels;

    els.psetSelect.onchange = (e) => {
      setError("");
      populatePropSelects(e.target.value);
    };

    cbIds.forEach((cbId, idx) => {
      const cb = document.getElementById(cbId);
      const sel = document.getElementById(propSelectIds[idx]);
      cb.addEventListener("change", () => { if (!cb.checked) sel.value = ""; });
    });

    // Start
    (async () => {
      try{
        await connectToWorkspace();
      }catch(err){
        console.error(err);
        setError("Klarte ikke √• koble til Workspace API: " + (err.message || err));
        setStatus("Feil.");
      }
    })();
  </script>
</body>
</html>
